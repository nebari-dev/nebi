package auth

import (
	"sync"
	"time"
)

const cliSessionTTL = 10 * time.Minute

// CLISession holds the state for a pending or completed CLI login.
type CLISession struct {
	Token    string
	Username string
	Created  time.Time
}

// CLISessionStore is a thread-safe in-memory store for CLI login sessions.
// Sessions are keyed by a random code generated by the CLI.
type CLISessionStore struct {
	mu       sync.RWMutex
	sessions map[string]*CLISession
}

// NewCLISessionStore creates a new CLI session store.
func NewCLISessionStore() *CLISessionStore {
	return &CLISessionStore{
		sessions: make(map[string]*CLISession),
	}
}

// Create registers a pending session (no token yet).
func (s *CLISessionStore) Create(code string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.cleanup()
	s.sessions[code] = &CLISession{Created: time.Now()}
}

// Complete fills in the token and username for a pending session.
// Returns false if the code doesn't exist or has expired.
func (s *CLISessionStore) Complete(code, token, username string) bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	sess, ok := s.sessions[code]
	if !ok || time.Since(sess.Created) > cliSessionTTL {
		return false
	}
	sess.Token = token
	sess.Username = username
	return true
}

// Get returns a session by code. Returns nil if not found or expired.
func (s *CLISessionStore) Get(code string) *CLISession {
	s.mu.RLock()
	defer s.mu.RUnlock()
	sess, ok := s.sessions[code]
	if !ok || time.Since(sess.Created) > cliSessionTTL {
		return nil
	}
	return sess
}

// Delete removes a session by code.
func (s *CLISessionStore) Delete(code string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.sessions, code)
}

// cleanup removes expired sessions. Must be called with the lock held.
func (s *CLISessionStore) cleanup() {
	now := time.Now()
	for code, sess := range s.sessions {
		if now.Sub(sess.Created) > cliSessionTTL {
			delete(s.sessions, code)
		}
	}
}
